# Kubernetes Object Management

All Kubernetes Objects are identified by Unique name and Unique ID. Objects are defined with manifest files. These are ordinary text files that can be written in
YAML (Recommended option) or JSON format.

YAML files are less tedious to edit

```
# Required field: Which Kubernetes API version is used to create the object. 
# The Kubernetes protocol is versioned so as to help maintain backwards compatibility

apiVersion: apps/v1

# Defines the object you want
kind: Pod

# helps identify the object using name, unique id (automatically generated by Kubernetes), and an optional namespace. 
# You can define several related objects in the same YAML file (Best practice)

metadata:
# object names must be unique
    name: nginx
    # (uid is auto-generated : 4ddd474fn-f389-11f8-b38c-42010a8009z7) 
    # key-value tags for organizing your objects
    labels:
        app: nginx
spec:
    containers:
    - name: nginx
      image: nginx:latest
```

## Another Best Practice: Save YAML files in version control repos (Cloud Source Repo).

- This will help you track changes, or back out of changes when necessary
- Recreate/restore a cluster

**Object names**

All objects are identified by a unique name

**Labels**

Key value pairs with which you tag your objects, during or after their creation. They help organize your objects

For example you can use the ```kubectl``` command to retrieve pods that contain a label: app with the value of nginx.

```kubectl get pods -selector=app=nginx```

![Screen Shot 2021-10-10 at 1 19 34 PM](https://user-images.githubusercontent.com/40435982/136706462-6660dd37-b09d-41b3-bc6a-8be2f87547eb.png)

## Pods (without controller, inefficient, unamnageable) 
So one way to run 3 nginx servers would be to define 3 pod objects, each with its own section of YAML. 

Scaling YAML files is inconvenient

![Screen Shot 2021-10-10 at 1 28 22 PM](https://user-images.githubusercontent.com/40435982/136706747-af261b60-ad19-425e-802a-2be90281149c.png)

### Another problem... Pods have a lifecycle, they don't heal/repair themselves. They are meant to be ephemeral and disposable

![Screen Shot 2021-10-10 at 1 30 27 PM](https://user-images.githubusercontent.com/40435982/136706788-1fb23b94-cd59-4cbe-bda9-877f92851ff1.png)

This is another reason why you should not specify pods using individual files. There is a better way to manage your Kubernetes workloads with a better setup that maintains high availability along with horizontal scaling.

## Pods and Controller Objects

Declare a controller object whose job is to manage the state of the pods

![Screen Shot 2021-10-10 at 1 36 13 PM](https://user-images.githubusercontent.com/40435982/136707006-11315fe2-47be-4fec-a99b-80934ffa4000.png)

Examples of Controller objects

![Screen Shot 2021-10-10 at 1 36 30 PM](https://user-images.githubusercontent.com/40435982/136707021-371d979f-67d8-4b58-962f-bcb509cae4f8.png)

## Deployments ensure that the defined sets of pods are running
Example : Use Deployments for long lived software components, like Web servers (especially when we want to manage them as a group)

```
apiVersion: apps/v1
kind: Deployment
metadata:
    name: nginx-deployment
    labels:
        app: nginx
spec:
# how many replica pods
    replicas: 3
    template:
       metadata:
          labels:
            app: nginx
       spec:
       # which container should run within these pods
          containers:
            - name: nginx
            # which volume should be mounted
              image: nginx:latest
```

## Allocating resource quotas

Its probable that you will use a single cluster for multiple projects (informal definition of projects, thing you are working on with colleagues. Each GKE cluster is associated with only 1 GCP project)

Its also essential to maintain resource quotas based on projects, department, or team.

## Namespaces - Abstract one cluster into multiple clusters called Namespaces
Namespaces help keep things tidy between your various projects (informal). 

### Object names need only be unique within the same namespace, not across all namespaces

![Screen Shot 2021-10-10 at 5 24 39 PM](https://user-images.githubusercontent.com/40435982/136713401-0ecae817-a06b-4113-a41f-20e42c05a2cb.png)

Namespaces are useful for example for having replication of your production env in dev, or test environments.

There are 3 initial namespaces in a cluster:
- **Default namespace** - For objects with no other namespace defined.
- **Kube-system namespace** - For objects created by Kubernetes itself. (ConfigMap, Secrets, Controllers, Deployments)
- **Kube-public** - For objects publicly readable to all users. Tool for disseminating information to everythiong running in a cluster. 

# Best practice tip: Apply namespaces at the command line level. Its more flexible
Recall: Namespaces are useful for example for having replication of your production env in dev, or test environments.

If you embed namespaces in your YAML files, this decreases flexibility and usefulness of namespaces

![Screen Shot 2021-10-10 at 5 32 52 PM](https://user-images.githubusercontent.com/40435982/136713599-482b69d8-dacd-4fe5-99ff-7e33964f0f65.png)



